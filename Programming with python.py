# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cxs_859foOtfNYfqKUSpeuEy8mwPPGBS
"""

import pandas as pd
import numpy as np
from sqlalchemy import create_engine, Column, Float, Integer, String
from sqlalchemy.orm import declarative_base, sessionmaker
import matplotlib.pyplot as plt
import unittest

# Load data from CSV files
data_train = pd.read_csv('train.csv')
data_test = pd.read_csv('test.csv')
data_ideal = pd.read_csv('ideal.csv')

# Initialize database engine
db_engine = create_engine('sqlite:///math_functions.db')
Base = declarative_base()

# Table schema for training dataset
class TrainDataset(Base):
    __tablename__ = 'train_dataset'
    id = Column(Integer, primary_key=True)
    x_value = Column(Float)
    y_train_1 = Column(Float)
    y_train_2 = Column(Float)
    y_train_3 = Column(Float)
    y_train_4 = Column(Float)

# Table schema for ideal function dataset
class IdealFunctionSet(Base):
    __tablename__ = 'ideal_function_set'
    id = Column(Integer, primary_key=True)
    x_value = Column(Float)

    # Dynamically adding columns for y_ideal_1 to y_ideal_50
    locals().update({f"y_ideal_{i}": Column(Float) for i in range(1, 51)})


# Table schema for test dataset with mapping
class TestDatasetMapping(Base):
    __tablename__ = 'test_dataset_mapping'
    id = Column(Integer, primary_key=True)
    x_value = Column(Float)
    y_test_value = Column(Float)
    deviation_delta = Column(Float)
    mapped_function = Column(String)

# Generate tables
Base.metadata.create_all(db_engine)

# Store data in the database
data_train.to_sql('train_dataset', db_engine, if_exists='replace', index=False)
data_ideal.to_sql('ideal_function_set', db_engine, if_exists='replace', index=False)
data_test.to_sql('test_dataset_mapping', db_engine, if_exists='replace', index=False)

# Retrieve and display data
da_train = pd.read_sql('SELECT * FROM train_dataset', con=db_engine)
print(da_train.head())

da_ideal = pd.read_sql('SELECT * FROM ideal_function_set', con=db_engine)
print(da_ideal.head())

da_test = pd.read_sql('SELECT * FROM test_dataset_mapping', con=db_engine)
print(da_test.head())

# Function to compute least squares deviation
def compute_least_squares(y_actual, y_predicted):
    return np.sum((y_actual - y_predicted) ** 2)

# Determine the best-matching ideal function for each training set
optimal_function_mappings = {}
for train_column in data_train.columns[1:]:  # Excluding 'x_value'
    min_dev = float('inf')
    best_fit = None

    for ideal_column in data_ideal.columns[1:]:  # Excluding 'x_value'
        deviation = compute_least_squares(data_train[train_column], data_ideal[ideal_column])
        if deviation < min_dev:
            min_dev = deviation
            best_fit = ideal_column

    optimal_function_mappings[train_column] = (best_fit, min_dev)

print("Optimal Function Mapping:", optimal_function_mappings)

# Function to map test data against ideal functions
def associate_test_points(data_test, data_ideal, function_mappings, threshold_factor=np.sqrt(2)):
    output_records = []

    for _, point in data_test.iterrows():
        x_val, y_test_val = point['x'], point['y']

        for train_col, (ideal_col, max_deviation) in function_mappings.items():
            y_ideal_val = data_ideal.loc[data_ideal['x'] == x_val, ideal_col].values[0]
            deviation = abs(y_test_val - y_ideal_val)

            if deviation <= threshold_factor * max_deviation:
                output_records.append({'x_value': x_val, 'y_test_value': y_test_val, 'mapped_function': ideal_col, 'deviation_delta': deviation})

    return pd.DataFrame(output_records)

# Execute mapping
final_mapped_results = associate_test_points(data_test, data_ideal, optimal_function_mappings)
print(final_mapped_results.head())

# Plotting training data vs ideal function
for train_col, (ideal_col, _) in optimal_function_mappings.items():
    plt.figure(figsize=(10, 6))
    plt.scatter(data_train['x'], data_train[train_col], label=f'{train_col} (Training Data)', color='blue')
    plt.plot(data_ideal['x'], data_ideal[ideal_col], label=f'{ideal_col} (Ideal Function)', color='yellow')

    test_subset = final_mapped_results[final_mapped_results['mapped_function'] == ideal_col]
    plt.scatter(test_subset['x_value'], test_subset['y_test_value'], label='Mapped Test Data', color='red')

    plt.xlabel('X Value')
    plt.ylabel('Y Value')
    plt.title(f"{train_col} vs {ideal_col}")
    plt.legend()
    plt.show()

# Sample data for validation
dummy_train = {
    'x': [2.2, 1.6, 8],
    'y_train1': [5, 10, 15],
    'y_train2': [2.2, 2.6, 8.2],
    'y_train3': [32, 1.6, 5.4],
    'y_train4': [2, 5, 8]
}

dummy_ideal = {
    'x': [2.2, 1.6, 8],
    'y_ideal1': [6.6, 8.1, 3.4],
    'y_ideal2': [2.1, 2.9, 2.5],
    'y_ideal3': [3.0, 6.1, 5.7],
    'y_ideal4': [4.1, 51, 2.9],
    'y_ideal5': [12, 2.4, 5.2]
}

train_data = pd.DataFrame(dummy_train)
ideal_data = pd.DataFrame(dummy_ideal)

# Unit test to validate mapping
class ValidateIdealMapping(unittest.TestCase):

    def calculate_least_squares(self, y_train, y_ideal):
        return np.sum((y_train - y_ideal) ** 2)

    def test_optimal_functions(self):
        function_mappings = {}
        for train_col in train_data.columns[1:]:
            min_deviation = float('inf')
            best_function = None

            for ideal_col in ideal_data.columns[1:]:
                deviation = self.calculate_least_squares(train_data[train_col], ideal_data[ideal_col])
                if deviation < min_deviation:
                    min_deviation = deviation
                    best_function = ideal_col

            function_mappings[train_col] = best_function

        self.assertTrue(all(col in function_mappings for col in ['y_train1', 'y_train2', 'y_train3', 'y_train4']))

unittest.main(argv=[''], exit=False)